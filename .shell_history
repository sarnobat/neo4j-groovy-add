start n=node(*) MATCH n<-[r?:CONTAINS]-source where source is null and not(has(n.type)) AND id(n) > 0 return ID(n),n.title?,n.url?
;
start n=node(*) MATCH n<-[r?:CONTAINS]-source where source is null and not(has(n.type)) AND id(n) > 0 return ID(n),n.title?,n.url?;
start n=node(*) MATCH n<-[r?:CONTAINS]-source where not(has(n.type)) AND id(n) > 0 return ID(n),n.title?,n.url?;
start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or source.name = 'root') and not(has(n.type)) AND id(n) > 0 return ID(n),n.title?,n.url?
start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or source.name = 'root') and not(has(n.type)) AND id(n) > 0 return ID(n),n.title?,n.url?;
start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or ID(source) = 45) and not(has(n.type)) AND id(n) > 0 return ID(n),n.title?,n.url?
;
start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or ID(source) = 45) and not(has(n.type)) AND id(n) > 0 return ID(n),n.title?,n.url?;
start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or source.name = 'root') and not(has(n.type)) AND id(n) > 0 return ID(n),n.title?,n.url?
start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or source.name = 'root') and not(has(n.type)) AND id(n) > 0 return ID(n),n.title?,n.url?;
cd -a 39
ls
cd -a 28666
ls
pwd
start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null) and not(has(n.type)) AND id(n) > 0 return ID(n),n.title?,n.url?;
create n return n;
start n=node(45)
;
start root=node(*) match root where has(root.type) and root.type = 'categoryNode' and root.name = 'root';
start root=node(*) match root where has(root.type) and root.type = 'categoryNode' and root.name = 'root' return root;
start root=node(*) match root-[c:CONTAINS]-n where has(root.type) and root.type = 'categoryNode' and root.name = 'root' return root;
start root=node(*) match root-[c:CONTAINS]-n where has(root.type) and root.type = 'categoryNode' and root.name = 'root' return n;
start root=node(*) match root-[c:CONTAINS]->n where has(root.type) and root.type = 'categoryNode' and root.name = 'root' return n;
start root=node(*) match root-[c:CONTAINS]->n where has(root.type) and root.type = 'categoryNode' and root.name = 'root' return c;
start root=node(*) match root-[c:CONTAINS]->n where has(root.type) and root.type = 'categoryNode' and root.name = 'root' return root,c,n;
start root=node(*) match root-[c:CONTAINS]->n where has(root.type) and root.type = 'categoryNode' and root.name = 'root' return id(c);
start a=node({parentId}),b=node({childId}) create a-[r:CONTAINS]->b return a,r,b;
start a=node({45}),b=node({28660}) create a-[r:CONTAINS]->b return a,r,b;
start a=node(45),b=node(28660) create a-[r:CONTAINS]->b return a,r,b;
start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or ID(source) = 45) and not(has(n.type)) AND id(n) > 0 return ID(n),n.title?,n.url?
;
start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or ID(source) = 46) and not(has(n.type)) AND id(n) > 0 return ID(n),n.title?,n.url?
;
cd -a 28748
rm 28748
rmnode .
rmnode 28748
rmnode 28749
rmnode 28750
rmnode 28751
rmnode 28752
cd 28753
rmnode 28753
rmnode 28753 -f
mkrel
cd 45
mkrel -t CONTAINS 46
mkrel -t CONTAINS 47
cd 45
mkrel -t CONTAINS 47
mkrel -t CONTAINS 48
mkrel -t CONTAINS 13335
rm 28755
rmnode 28755
rmnode 28755 -f
rmnode 28756
rmnode 28757
rmnode 28756 -f
rmnode 28757 -f
rmnode  -f 28758
28759
rmnode  -f 28759
rmnode  -f 28760
28762
cd -a 28762
pwd
cd -a 28787
rmnode 28787
rmnode 28787 -f
exit
START n=node(*) MATCH parent-[c:CONTAINS]->n WHERE has(n.name) and n.type == 'categoryNode' and id(parent) = 46 RETURN ID(n),n.name,n.key?;
START n=node(*) MATCH parent-[c:CONTAINS]->n WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = 46 RETURN ID(n),n.name,n.key?
;
rmnode 28788
rmnode 28788 -f
rmnode 28789
rmnode 28789 -f
rmnode 28790
rmnode 28790 -f
rmnode -f 28791
rmnode -f 28792
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE category.key = 'C' SET key = null
;
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE category.key = 'C' SET key = null;
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE category.key? = 'C' SET key = null;
cd 28763
cd 28763 -a
ls
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE category.key = 'C' SET category.key = null    ;
cd -a 28721
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE category.type = 'categoryNode' and category.key = 'C' SET category.key = null    ;
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) category.type = 'categoryNode' and category.key = 'C' SET category.key = null    
;
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' SET category.key = null    ;
cd -a 28763
ls
cd 28763 -a
ls
set key = 'C'
cd -a 28763
set key 'C'
ls
cd -a 28763
set key C
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' REMOVE category.key
;
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' REMOVE category.key RETURN category;
MATCH parent-[r:CONTAINS]->category WHERE parent=node(46) and has(category.key) and category.type = 'categoryNode' and category.key = 'C' REMOVE category.key RETURN category   ;
match c where id(c) = 3;
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' REMOVE category.key;
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C';;
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C';
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' RETURN parent;
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' RETURN category;
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' REMOVE category.key RETURN category;
MATCH parent-[r:CONTAINS]->category WHERE id(parent) = 46 has(category.key) and category.type = 'categoryNode' and category.key = 'C' REMOVE category.key RETURN category;
MATCH andres WHERE andres.name='Andres' REMOVE andres.age RETURN andres;
help
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' DELETE category.key RETURN category   ;
cd import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import org.apache.commons.io.IOUtils;
import org.glassfish.jersey.jdkhttp.JdkHttpServerFactory;
import org.glassfish.jersey.server.ResourceConfig;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.apache.commons.lang.*;
import com.google.common.collect.Sets;
import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.WebResource;
public class Server {
@Path("yurl")
public static class HelloWorldResource { // Must be public
final String CYPHER_URI = "http://netgear.rohidekar.com:7474/db/data/cypher";
@GET
@Path("parent")
@Produces("application/json")
public Response parent(@QueryParam("nodeId") Integer nodeId) throws JSONException,
IOException {
Map<String, Object> params = new HashMap<String, Object>();
params.put("nodeId", nodeId);
// TODO: order these by most recent-first (so that they appear this
// way in the UI)
JSONObject json = queryNeo4j(
"start n=node({nodeId}) MATCH p-[r:CONTAINS]->n RETURN id(p)", params);
JSONArray data = (JSONArray) json.get("data");
JSONArray ret = new JSONArray();
for (int i = 0; i < data.length(); i++) {
JSONArray a = data.getJSONArray(i);
JSONObject o = new JSONObject();
String id = (String) a.get(0);
o.put("id", id);
ret.put(o);
}
return Response.ok().header("Access-Control-Allow-Origin", "*").entity(ret.toString())
.type("application/json").build();
}
@GET
@Path("uncategorized")
@Produces("application/json")
public Response uncategorized(@QueryParam("rootId") Integer rootId) throws JSONException,
IOException {
// TODO: check rootId is not null or empty
// TODO: the source is null clause should be obsoleted
Map<String, Object> params = new HashMap<String, Object>();
params.put("rootId", rootId);
// TODO: order these by most recent-first (so that they appear this
// way in the UI)
JSONObject json = queryNeo4j(
"start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or ID(source) = {rootId}) and not(has(n.type)) AND id(n) > 0 return distinct ID(n),n.title?,n.url?",
params);
JSONArray data = (JSONArray) json.get("data");
JSONArray ret = new JSONArray();
for (int i = 0; i < data.length(); i++) {
JSONArray a = data.getJSONArray(i);
JSONObject o = new JSONObject();
String id = (String) a.get(0);
o.put("id", id);
String title = (String) a.get(1);
String url = (String) a.get(2);
o.put("title", title);
o.put("url", url);
ret.put(o);
}
return Response.ok().header("Access-Control-Allow-Origin", "*").entity(ret.toString())
.type("application/json").build();
}
@GET
@Path("keysUpdate")
@Produces("application/json")
// TODO: we will have to start supporting disassociation of key bindings
// with child categories
public Response keysUpdate(@QueryParam("parentId") Integer parentId,
@QueryParam("newKeyBindings") String newKeyBindings,
@QueryParam("oldKeyBindings") String oldKeyBindings) throws JSONException,
IOException {
System.out.println("keysUpdate");
Set<String> oldKeyBindingsSet = new HashSet<String>();
Collections.addAll(oldKeyBindingsSet, oldKeyBindings.trim().split("\n"));
Set<String> newKeyBindingsSet = new HashSet<String>();
Collections.addAll(newKeyBindingsSet, newKeyBindings.trim().split("\n"));
// NOTE: This is not symmetric (commutative?). If you want to
// support removal do that in a separate loop
Set<String> newKeyBindingLines = Sets.difference(newKeyBindingsSet, oldKeyBindingsSet);
System.out.println("Old: " + oldKeyBindingsSet);
System.out.println("New: " + newKeyBindingsSet);
System.out.println("Difference: " + newKeyBindingLines);
Map<String, String> keyBindings = new HashMap<String, String>();
for (String newKeyBinding : newKeyBindingLines) {
if (newKeyBinding.trim().startsWith("#") && !newKeyBinding.trim().startsWith("#=")) {
continue;// A commented out keybinding
}
String[] lineElements = newKeyBinding.split("=");
String aKeyCode = lineElements[0].trim();
// Ignore trailing comments
String[] aRightHandSideElements = lineElements[1].trim().split("#");
String aName = aRightHandSideElements[0].trim();
//
System.out.println("Accepting proposal to create key binding for " + aName + "("
+ aKeyCode + ")");
keyBindings.put(aKeyCode, aName);
// TODO: if it fails, recover and create the remaining ones
}
for (String aKeyCode : keyBindings.keySet()) {
String aName = keyBindings.get(aKeyCode);
//{
Map<String, Object> paramValues = new HashMap<String, Object>();
paramValues.put("parendId", parentId);
paramValues.put("key", aKeyCode);
System.out.println("About to remove keybinding for " + aName);
JSONObject json = queryNeo4j(
"start parent=node({parentId}) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = {key} DELETE category.key RETURN category",
paramValues);
// TODO: remove the keyCode associated with the current
// category
keyBindings.remove(aKeyCode);
System.out.println("Removed keybinding for " + aName);
//}
createNewKeyBinding(aName, aKeyCode, parentId);
}
JSONArray ret = getKeys(parentId);
return Response.ok().header("Access-Control-Allow-Origin", "*").entity(ret.toString())
.type("application/json").build();
}
private void createNewKeyBinding(String aName, String aKeyCode, Integer parentId)
throws IOException, JSONException {
// Create a new node
// TODO: Check if the category already exists
Map<String, Object> paramValues = new HashMap<String, Object>();
paramValues.put("name", aName);
paramValues.put("key", aKeyCode);
paramValues.put("type", "categoryNode");
paramValues.put("created", System.currentTimeMillis());
System.out.println("cypher params: " + paramValues);
// TODO: first check if there is already a node with this name,
// which is for re-associating the keycode with the category
JSONObject json = queryNeo4j(
"CREATE (n { name : {name} , key : {key}, created: {created} , type :{type}}) RETURN id(n)",
paramValues);
System.out.println(json.toString());
Integer newCategoryNodeId = Integer.parseInt((String) ((JSONArray) ((JSONArray) json
.get("data")).get(0)).get(0));
relateHelper(parentId, newCategoryNodeId);
}
@GET
@Path("keys")
@Produces("application/json")
public Response keys(@QueryParam("parentId") Integer parentId) throws JSONException,
IOException {
JSONArray ret = getKeys(parentId);
return Response.ok().header("Access-Control-Allow-Origin", "*").entity(ret.toString())
.type("application/json").build();
}
public JSONArray getKeys(Integer parentId) throws IOException, JSONException {
Map<String, Object> params = new HashMap<String, Object>();
params.put("parentId", parentId);
JSONObject json = queryNeo4j(
"START n=node(*) MATCH parent-[c:CONTAINS]->n WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = {parentId} RETURN ID(n),n.name,n.key?",
params);
JSONArray data = (JSONArray) json.get("data");
JSONArray ret = new JSONArray();
for (int i = 0; i < data.length(); i++) {
JSONArray a = data.getJSONArray(i);
JSONObject o = new JSONObject();
String id = (String) a.get(0);
o.put("id", id);
String title = (String) a.get(1);
String url = (String) a.get(2);
o.put("name", title);
o.put("key", url);// TODO: this could be null
ret.put(o);
}
return ret;
}
@GET
@Path("stash")
@Produces("application/json")
public Response stash(@QueryParam("param1") String url) throws JSONException, IOException {
String httpUrl = URLDecoder.decode(url, "UTF-8");
String title = getTitle(new URL(httpUrl));
Map<String, Object> paramValues = new HashMap<String, Object>();
paramValues.put("url", httpUrl);
paramValues.put("title", title);
paramValues.put("created", System.currentTimeMillis());
JSONObject json = queryNeo4j(
"CREATE (n { title : {title} , url : {url}, created: {created} }) RETURN id(n)",
paramValues);
JSONArray newNodeId = (JSONArray) ((JSONArray) json.get("data")).get(0);
System.out.println("New node: " + newNodeId.get(0));
// TODO: Do not hard-code the root ID
cd -a 28763
ls
cd -a 28763
ls
