rmnode 28755
rmnode 28755 -f
rmnode 28756
rmnode 28757
rmnode 28756 -f
rmnode 28757 -f
rmnode  -f 28758
28759
rmnode  -f 28759
rmnode  -f 28760
28762
cd -a 28762
pwd
cd -a 28787
rmnode 28787
rmnode 28787 -f
exit
START n=node(*) MATCH parent-[c:CONTAINS]->n WHERE has(n.name) and n.type == 'categoryNode' and id(parent) = 46 RETURN ID(n),n.name,n.key?;
START n=node(*) MATCH parent-[c:CONTAINS]->n WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = 46 RETURN ID(n),n.name,n.key?
;
rmnode 28788
rmnode 28788 -f
rmnode 28789
rmnode 28789 -f
rmnode 28790
rmnode 28790 -f
rmnode -f 28791
rmnode -f 28792
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE category.key = 'C' SET key = null
;
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE category.key = 'C' SET key = null;
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE category.key? = 'C' SET key = null;
cd 28763
cd 28763 -a
ls
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE category.key = 'C' SET category.key = null    ;
cd -a 28721
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE category.type = 'categoryNode' and category.key = 'C' SET category.key = null    ;
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) category.type = 'categoryNode' and category.key = 'C' SET category.key = null    
;
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' SET category.key = null    ;
cd -a 28763
ls
cd 28763 -a
ls
set key = 'C'
cd -a 28763
set key 'C'
ls
cd -a 28763
set key C
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' REMOVE category.key
;
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' REMOVE category.key RETURN category;
MATCH parent-[r:CONTAINS]->category WHERE parent=node(46) and has(category.key) and category.type = 'categoryNode' and category.key = 'C' REMOVE category.key RETURN category   ;
match c where id(c) = 3;
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' REMOVE category.key;
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C';;
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C';
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' RETURN parent;
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' RETURN category;
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' REMOVE category.key RETURN category;
MATCH parent-[r:CONTAINS]->category WHERE id(parent) = 46 has(category.key) and category.type = 'categoryNode' and category.key = 'C' REMOVE category.key RETURN category;
MATCH andres WHERE andres.name='Andres' REMOVE andres.age RETURN andres;
help
 start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' DELETE category.key RETURN category   ;
cd import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import org.apache.commons.io.IOUtils;
import org.glassfish.jersey.jdkhttp.JdkHttpServerFactory;
import org.glassfish.jersey.server.ResourceConfig;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.apache.commons.lang.*;
import com.google.common.collect.Sets;
import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.WebResource;
public class Server {
@Path("yurl")
public static class HelloWorldResource { // Must be public
final String CYPHER_URI = "http://netgear.rohidekar.com:7474/db/data/cypher";
@GET
@Path("parent")
@Produces("application/json")
public Response parent(@QueryParam("nodeId") Integer nodeId) throws JSONException,
IOException {
Map<String, Object> params = new HashMap<String, Object>();
params.put("nodeId", nodeId);
// TODO: order these by most recent-first (so that they appear this
// way in the UI)
JSONObject json = queryNeo4j(
"start n=node({nodeId}) MATCH p-[r:CONTAINS]->n RETURN id(p)", params);
JSONArray data = (JSONArray) json.get("data");
JSONArray ret = new JSONArray();
for (int i = 0; i < data.length(); i++) {
JSONArray a = data.getJSONArray(i);
JSONObject o = new JSONObject();
String id = (String) a.get(0);
o.put("id", id);
ret.put(o);
}
return Response.ok().header("Access-Control-Allow-Origin", "*").entity(ret.toString())
.type("application/json").build();
}
@GET
@Path("uncategorized")
@Produces("application/json")
public Response uncategorized(@QueryParam("rootId") Integer rootId) throws JSONException,
IOException {
// TODO: check rootId is not null or empty
// TODO: the source is null clause should be obsoleted
Map<String, Object> params = new HashMap<String, Object>();
params.put("rootId", rootId);
// TODO: order these by most recent-first (so that they appear this
// way in the UI)
JSONObject json = queryNeo4j(
"start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or ID(source) = {rootId}) and not(has(n.type)) AND id(n) > 0 return distinct ID(n),n.title?,n.url?",
params);
JSONArray data = (JSONArray) json.get("data");
JSONArray ret = new JSONArray();
for (int i = 0; i < data.length(); i++) {
JSONArray a = data.getJSONArray(i);
JSONObject o = new JSONObject();
String id = (String) a.get(0);
o.put("id", id);
String title = (String) a.get(1);
String url = (String) a.get(2);
o.put("title", title);
o.put("url", url);
ret.put(o);
}
return Response.ok().header("Access-Control-Allow-Origin", "*").entity(ret.toString())
.type("application/json").build();
}
@GET
@Path("keysUpdate")
@Produces("application/json")
// TODO: we will have to start supporting disassociation of key bindings
// with child categories
public Response keysUpdate(@QueryParam("parentId") Integer parentId,
@QueryParam("newKeyBindings") String newKeyBindings,
@QueryParam("oldKeyBindings") String oldKeyBindings) throws JSONException,
IOException {
System.out.println("keysUpdate");
Set<String> oldKeyBindingsSet = new HashSet<String>();
Collections.addAll(oldKeyBindingsSet, oldKeyBindings.trim().split("\n"));
Set<String> newKeyBindingsSet = new HashSet<String>();
Collections.addAll(newKeyBindingsSet, newKeyBindings.trim().split("\n"));
// NOTE: This is not symmetric (commutative?). If you want to
// support removal do that in a separate loop
Set<String> newKeyBindingLines = Sets.difference(newKeyBindingsSet, oldKeyBindingsSet);
System.out.println("Old: " + oldKeyBindingsSet);
System.out.println("New: " + newKeyBindingsSet);
System.out.println("Difference: " + newKeyBindingLines);
Map<String, String> keyBindings = new HashMap<String, String>();
for (String newKeyBinding : newKeyBindingLines) {
if (newKeyBinding.trim().startsWith("#") && !newKeyBinding.trim().startsWith("#=")) {
continue;// A commented out keybinding
}
String[] lineElements = newKeyBinding.split("=");
String aKeyCode = lineElements[0].trim();
// Ignore trailing comments
String[] aRightHandSideElements = lineElements[1].trim().split("#");
String aName = aRightHandSideElements[0].trim();
//
System.out.println("Accepting proposal to create key binding for " + aName + "("
+ aKeyCode + ")");
keyBindings.put(aKeyCode, aName);
// TODO: if it fails, recover and create the remaining ones
}
for (String aKeyCode : keyBindings.keySet()) {
String aName = keyBindings.get(aKeyCode);
//{
Map<String, Object> paramValues = new HashMap<String, Object>();
paramValues.put("parendId", parentId);
paramValues.put("key", aKeyCode);
System.out.println("About to remove keybinding for " + aName);
JSONObject json = queryNeo4j(
"start parent=node({parentId}) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = {key} DELETE category.key RETURN category",
paramValues);
// TODO: remove the keyCode associated with the current
// category
keyBindings.remove(aKeyCode);
System.out.println("Removed keybinding for " + aName);
//}
createNewKeyBinding(aName, aKeyCode, parentId);
}
JSONArray ret = getKeys(parentId);
return Response.ok().header("Access-Control-Allow-Origin", "*").entity(ret.toString())
.type("application/json").build();
}
private void createNewKeyBinding(String aName, String aKeyCode, Integer parentId)
throws IOException, JSONException {
// Create a new node
// TODO: Check if the category already exists
Map<String, Object> paramValues = new HashMap<String, Object>();
paramValues.put("name", aName);
paramValues.put("key", aKeyCode);
paramValues.put("type", "categoryNode");
paramValues.put("created", System.currentTimeMillis());
System.out.println("cypher params: " + paramValues);
// TODO: first check if there is already a node with this name,
// which is for re-associating the keycode with the category
JSONObject json = queryNeo4j(
"CREATE (n { name : {name} , key : {key}, created: {created} , type :{type}}) RETURN id(n)",
paramValues);
System.out.println(json.toString());
Integer newCategoryNodeId = Integer.parseInt((String) ((JSONArray) ((JSONArray) json
.get("data")).get(0)).get(0));
relateHelper(parentId, newCategoryNodeId);
}
@GET
@Path("keys")
@Produces("application/json")
public Response keys(@QueryParam("parentId") Integer parentId) throws JSONException,
IOException {
JSONArray ret = getKeys(parentId);
return Response.ok().header("Access-Control-Allow-Origin", "*").entity(ret.toString())
.type("application/json").build();
}
public JSONArray getKeys(Integer parentId) throws IOException, JSONException {
Map<String, Object> params = new HashMap<String, Object>();
params.put("parentId", parentId);
JSONObject json = queryNeo4j(
"START n=node(*) MATCH parent-[c:CONTAINS]->n WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = {parentId} RETURN ID(n),n.name,n.key?",
params);
JSONArray data = (JSONArray) json.get("data");
JSONArray ret = new JSONArray();
for (int i = 0; i < data.length(); i++) {
JSONArray a = data.getJSONArray(i);
JSONObject o = new JSONObject();
String id = (String) a.get(0);
o.put("id", id);
String title = (String) a.get(1);
String url = (String) a.get(2);
o.put("name", title);
o.put("key", url);// TODO: this could be null
ret.put(o);
}
return ret;
}
@GET
@Path("stash")
@Produces("application/json")
public Response stash(@QueryParam("param1") String url) throws JSONException, IOException {
String httpUrl = URLDecoder.decode(url, "UTF-8");
String title = getTitle(new URL(httpUrl));
Map<String, Object> paramValues = new HashMap<String, Object>();
paramValues.put("url", httpUrl);
paramValues.put("title", title);
paramValues.put("created", System.currentTimeMillis());
JSONObject json = queryNeo4j(
"CREATE (n { title : {title} , url : {url}, created: {created} }) RETURN id(n)",
paramValues);
JSONArray newNodeId = (JSONArray) ((JSONArray) json.get("data")).get(0);
System.out.println("New node: " + newNodeId.get(0));
// TODO: Do not hard-code the root ID
cd -a 28763
ls
cd -a 28763
ls
START n=node(*) MATCH parent-[c:CONTAINS]->n WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = {parentId} RETURN ID(n),n.name,n.key?;
START n=node(*) MATCH parent-[c:CONTAINS]->n WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = 46 RETURN ID(n),n.name,n.key?
;
cd 28763
cd 28763 -a
set key C
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = C DELETE category.key RETURN category;
start parent=node(46) MATCH parent-[r:CONTAINS]->category WHERE has(category.key) and category.type = 'categoryNode' and category.key = 'C' DELETE category.key RETURN category;
cd -a 28763 
ls
set key C
ls
cd 12305
cd 12305 -a
cd -a 28793
unset key
set key
remove key
delete key
ls
help
rm key
ls
cd 28763
cd 28763 -a
set key C
START parent=node(46) MATCH parent -[r:CONTAINS]-> existingCategory WHERE existingCategory.name = 'c programming';
START parent=node(46) MATCH parent -[r:CONTAINS]-> existingCategory WHERE existingCategory.name = 'c programming' RETURN existr;;
START parent=node(46) MATCH parent -[r:CONTAINS]-> existingCategory WHERE existingCategory.name = 'c programming' RETURN r;
cd -a 28782
START parent=node(46) MATCH parent -[r:CONTAINS]-> existingCategory WHERE has(existingCategory.type) and existingCategory.type = 'categoryNode' and existingCategory.name = 'c programming' RETURN r
;
START parent=node(46) MATCH parent -[r:CONTAINS]-> existingCategory WHERE has(existingCategory.type) and existingCategory.type = 'categoryNode' and existingCategory.name = 'c programming' RETURN parent,r,existingCategory;
START parent=node(46) MATCH parent -[r:CONTAINS]-> existingCategory WHERE has(existingCategory.type) and existingCategory.type = 'categoryNode' and existingCategory.name = 'c programming' RETURN parent.name,existingCategory.name;
START parent=node(46) MATCH parent -[r:CONTAINS]-> existingCategory WHERE has(existingCategory.type) and existingCategory.type = 'categoryNode' and existingCategory.name = 'c programmin' RETURN parent.name,existingCategory.name;
START parent=node(46) MATCH parent -[r:CONTAINS]-> existingCategory WHERE has(existingCategory.type) and existingCategory.type = 'categoryNode' and existingCategory.name = 'c programmin' RETURN existingCategory;
START parent=node(46) MATCH parent -[r:CONTAINS]-> existingCategory WHERE has(existingCategory.type) and existingCategory.type = 'categoryNode' and existingCategory.name = 'c programming' RETURN existingCategory;
cd -a 46
ls
cd -a 28767
rm
ode 28802
rmnode 28802 -f
start root=node({nodeId}) MATCH root-[r]->n RETURN id(n);
start root=node(0) MATCH root-[r]->n RETURN id(n);
start root=node(45) MATCH root-[r]->n RETURN id(n);
start root=node(45) MATCH root-[r]->n RETURN id(n), n.title?;
start root=node(0) MATCH root-[r]->n RETURN id(n);
start root=node(0) MATCH root-[r]->n RETURN n;
start root=node(0) MATCH root-[r]->n RETURN n.properties;
start root=node(0) MATCH root-[r]->n RETURN n.data;
cd 45
pwd
start node(0) return *;
start n=node(0) return n;
start n=node(0) match n->c return c;
start n=node(0) match n-->c return c;
start n=node(45) match n-->c return c;
start n=node(45) match n-->c where has(c.type) return c;
index --create node_auto_index -t Node
index --indexes
START nd =node(*) WHERE has(nd.node_auto_index) WITH nd SET nd.Property_Name = nd.Property_Name RETURN count(nd);
START nd =node(*) WHERE has(nd.node_auto_index) WITH nd SET nd.node_auto_index = nd.node_auto_index RETURN count(nd);
cd -a 28810
pwd
start n=node(0) return n;
start n=node(0) match n-->creturn c;
start n=node(0) match n-->c return c;
start n=node(0) match n-->c? return c;
start n=node(0) match n-[r]->c return c;
start n=node(0) match n-[r:CONTAINS]->c return c;
start n=node(0) match n-[r:CONTAINS?]->c return c;
start n=node(0) match n-[r?:CONTAINS]->c return c;
start n=node(0) match n-[r?]-(c) return c;
start n=node(0) match n--(c) return c;
start n=node(0) match n--c return c;
start n=node(0) match n<--c return c;
start n=node(0) match n<-->c return c;
start n=node(0) match n--c return c;
start n=node(0) match n-->c return c;
start n=node(0) match n--?c return c;
start n=node(0) match n-->c return c;
start n=node(0) match n--c return c;
start n=node(0) match n--c return n,c;
start n=node(0) match n--c return distinct c;
start root=node(0)  MATCH root--n RETURN n
;
start n=node(*) return n.name";
start n=node(*) return n.name?";
start n=node(*) return n.name?;
start n=node(*) return n.name?,n.created? order;
start n=node(*) return n.name?,n.created? order by n.created? desc;
 start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or ID(source) = {rootId}) and not(has(n.type)) AND id(n) > 0 return distinct ID(n),n.title?,n.url? ORDER BY n.created DESC;
 start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or ID(source) = {rootId}) and not(has(n.type)) AND id(n) > 0 return distinct ID(n),n.title?,n.url? ORDER BY n.created? DESC;
 start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or ID(source) = {rootId}) and not(has(n.type)) AND id(n) > 0 return distinct ID(n),n.title?,n.url?,n.created? ORDER BY n.created? DESC;
cd -a 28786
pwd
ls
set name web programming and design
cd -a 28786
ls
set name 'web programming and design'
ls
set name web2
ls
set name=web2
set name=web programming and design
l
ls
set name="web programming and design"
ls
set name "web programming and design"
ls
cd -a 13335
ls
mkrel 28975 
mkrel 28975 -t CONTAINS
ls -l
rmrel 28975
rmrel 13335  28975
 13335  28975
cd -a 13335
ls
rmrel 13335 28975
help
dbinfo
rmrel 28975
rmrel
pwd
rmrel 36991
ls
mkrel  28975 13335 -t CONTAINS
ls 
ls *
rmrel 36992
cd -a 28975
mkrel 13335 -t CONTAINS
ls 
cd -a 45
ls -l
start n=node(45) match n-[r:CONTAINS]->child where child.name='wrestling' return r;
start n=node(45) match n-[r:CONTAINS]->child where child.name?='wrestling' return r;
start n=node(45) match n-[r:CONTAINS]->child where child.name?='wrestling' return r.id;
start n=node(45) match n-[r:CONTAINS]->child where child.name?='wrestling' return id(r);
start n=node(45) match n-[r:CONTAINS]->child where child.name?='wrestling' return n.name,id(r),child.name;
start n=node(45) match n-[r:CONTAINS]->child where child.name?='wrestling' return n.name,id(r),child.name?;
rmrel 34600
start n=node(45) match n-[r:CONTAINS]->child where child.name?='wrestling' return n.name,id(r),child.name?;
start n=node(*) match n where has(n.created);
start n=node(*) match n where has(n.created) return n.created;
start n=node(*) match n where has(n.created) return n.created set n.ordinal=n.created;
start n=node(*) match n where has(n.created) set n.ordinal=n.created return n.created, n.ordinal;
cd -a 30361
ls
start n=node(1,2) retun n;
start n=node(1,2) return n;
start n=node(1),n2=node(2) return n,n2;
start n=node(1),n2=node(2) set n.ordinal=n2.ordinal, n2.ordinal=n.ordinal;
start n=node(29314),n2=node(29313) set n.ordinal=n2.ordinal, n2.ordinal=n.ordinal;
start n=node(29314),n2=node(29313) set n.ordinal=n2.ordinal, n2.ordinal=n.ordinal return n,n2;
start n=node(29314),n2=node(29313) set n.ordinal=n2.ordinal, n2.ordinal=n.ordinal return n.ordinal,n2.ordinal;
start n=node(29314),n2=node(29313) set n.temp=n2.ordinal, n2.ordinal=n.ordinal,n.ordinal=n.temp  return n.ordinal,n2.ordinal;
start n=node(29315),n2=node(29316) set n.temp=n2.ordinal, n2.ordinal=n.ordinal,n.ordinal=n.temp  return n.ordinal,n2.ordinal;
 start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or ID(source) = 45) and not(has(n.type)) AND id(n) > 0 return distinct ID(n),n.title?,n.url?,n.created? ORDER BY n.ordinal? DESC
;
 start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or ID(source) = 45) and not(has(n.type)) AND id(n) > 0 return distinct ID(n),n.title?,n.url?,n.created? ORDER BY n.ordinal DESC
;
 start n=node(*) MATCH n<-[r?:CONTAINS]-source where (source is null or ID(source) = 45) and not(has(n.type)) AND id(n) > 0 return distinct ID(n),n.title?,n.url?,n.created?,n.ordinal? ORDER BY n.ordinal? DESC
;
cd -a 29631
ls
START n=node(*) MATCH parent-[c:CONTAINS]->n WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = 45 RETURN ID(n),n.name;
START n=node(*) MATCH parent-[c:CONTAINS*]->n WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = 45 RETURN ID(n),n.name
START n=node(*) MATCH parent-[c:CONTAINS*]->n WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = 45 RETURN ID(n),n.name;
START n=node(*) MATCH parent-[c:CONTAINS*]->n WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = 45 RETURN distinct ID(n),n.name;
cd -a 45
ls
cd 0
ls
mkrel -t CONTAINS 45
ls
START n=node(*) MATCH parent-[c:CONTAINS]->n WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = {parentId} RETURN ID(n),n.name,n.key?
;
START n=node(*) MATCH parent-[c:CONTAINS]->n WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = 45 RETURN ID(n),n.name,n.key?;
cd -a 100
cd -a 55
cd 45
ls
cd 39736
pwd
cd 39736 -a
pwd
ls
START n=node(*) MATCH parent-[c:CONTAINS]->n ->[c2:CONTAINS]->n2 WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = 45  and has(n2.url) RETURN ID(n),n.name,n.key?,count(n2);
START n=node(*) MATCH parent-[c:CONTAINS]->n -[c2:CONTAINS]->n2 WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = 45  and has(n2.url) RETURN ID(n),n.name,n.key?,count(n2);
START n=node(*) MATCH parent-[c:CONTAINS]->n -[c2:CONTAINS*]->n2 WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = 45  and has(n2.url) RETURN ID(n),n.name,n.key?,count(n2);
START n=node(*) MATCH parent-[c:CONTAINS]->n -[c2:CONTAINS*]->n2 WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = 45  and has(n2.url) RETURN ID(n),n.name,n.key?,count(n2) as c order by c;
START n=node(*) MATCH parent-[c:CONTAINS]->n -[c2:CONTAINS*]->n2 WHERE has(n.name) and n.type = 'categoryNode' and id(parent) = 45  and has(n2.url) RETURN ID(n),n.name,n.key?,count(n2) as c order by c desc;
start n=node(45) match n-[c:CONTAINS]->child where has(child.name) return n,c,child;
start n=node(45) match parent-[c:CONTAINS]->n where has(parent.name) return *;
cd -a 37658
start n=node(45) match parent-[c:CONTAINS]->n where has(parent.name) return *;
start n=node(37658) match parent-[c:CONTAINS]->n where has(parent.name) return *;
start n=node(37658) match n-[c:CONTAINS]->n where has(parent.name) return *;
start n=node(37658) match n-[c:CONTAINS]->n  return *;
rmrel 300508
rmrel 300507
start n=node(29196) match n-[CONTAINS]->u where has(u.name) return n.name, count(u) as cnt;
start n=node(29196) match n-[CONTAINS]->u where has(u.name) return n.name, u.name;
start n=node(29196) match n-[CONTAINS]->u where has(u.title) return n.name, u.name;
start n=node(29196) match n-[CONTAINS]->u where has(u.title) return n.name, u.title;
rmnode 488382
rmnode -f 4883821
rmnode -f 488382
